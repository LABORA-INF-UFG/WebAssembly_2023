<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"
		name="viewport" />
	<meta content="IE=edge" http-equiv="X-UA-Compatible" />
	<title>AlvaAR Video</title>
	<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		*:focus {
			outline: none !important
		}

		html,
		body {
			font-family: 'Helvetica', sans-serif;
			width: 100vw;
			height: 100vh;
			font-size: 12px;
			font-weight: 300;
			background: #fff;
		}

		#container {
			padding-bottom: 50px;
			text-align: center;
			display: none;
			position: relative;
			user-select: none;
		}

		#container::after {
			content: "Click on video to add 3d objects";
			text-align: center;
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
		}

		#container>div {
			display: inline-flex;
			vertical-align: top;
			margin: 100px 15px 0 15px;
			padding: 0;
			position: relative;
			user-select: none;
			outline: 1px solid #d20000;
		}

		#container>div>canvas {
			position: absolute;
			left: 0;
			top: 0;
			user-select: none;
		}

		#container>div>canvas:first-child {
			display: inline-block;
			position: relative;
		}

		.tracking #container>div {
			outline: 1px solid #bebebe;
		}

		@media only screen and (max-device-width: 800px) {
			body {
				background: #000;
			}

			#container {
				padding-bottom: 0;
				text-align: center;
				background: #000;
			}

			#container::after {
				display: none;
				content: '';
			}

			#container>div {
				margin: 0;
				padding: 0;
				box-shadow: none;
			}

			#renderer-map {
				display: none !important;
			}
		}
	</style>
</head>

<body>
	<div id="container">
		<div id="renderer-cam">
			<canvas id="renderer-video"></canvas>
		</div>
		<div id="renderer-map"></div>
	</div>
	<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"
		integrity="sha384-Gr6Lu2Ajx28mzwyVR8CFkULdCU7kMlZ9UthllibdOSo6qAiN+yXNHqtgdTvFXMT4"
		crossorigin="anonymous"></script>
	<script type="module">
		import { ARSimpleView, ARSimpleMap } from "/scripts/view.js";
		import { Video, onFrame, getCSV, Queue } from "/scripts/utils.js";

		//const serverUrl = "192.168.10.2:3000";
		const serverUrl = "localhost:3000";
		const eventStart = new Event("start");
		const eventEnd = new Event("end");

		const initializeServer = async (serverUrl, width, height) => {
			const socket = io(serverUrl, { reconnection: false });

			await new Promise(resolve => {
				socket.io.on("error", (error) => {
					error = new Error("Could not connect to " + serverUrl);
					window.alert("Não foi possível conectar ao servidor");
					console.error(error);
				});
				resolve();
			});

			await new Promise((resolve) => socket.on('connect', () => {
				socket.emit('initialize alva', { width, height }, () => resolve());
			}));

			return socket;
		}

		async function main() {
			const media = await Video.Initialize('/videos/wasm.mp4');
			const queue = new Queue();

			const socketPromise = initializeServer(serverUrl, media.width, media.height);

			let statistics = [
				['totalTime', 'slamTime', 'networkTime', 'renderTime', 'segmentationTime']
			];

			const $cam = document.getElementById('renderer-cam');
			const $map = document.getElementById('renderer-map');
			const ctx = document.getElementById('renderer-video').getContext('2d');

			ctx.canvas.width = media.width;
			ctx.canvas.height = media.height;

			const mapRenderer = new ARSimpleMap($map, media.width, media.height);
			const camRenderer = new ARSimpleView($cam, media.width, media.height, mapRenderer);
			$cam.parentElement.style.display = 'block';

			let videoHasEnded = false;
			let addCube = false;

			const socket = await socketPromise;

			let frameIndex = 0;

			const saveFrame = () => {
				const startSegmentationTime = performance.now();
				const frame = media.getImageData();
				const endSegmentationTime = performance.now();

				const totalSegmentationTime = endSegmentationTime - startSegmentationTime;

				const request = {
					width: frame.width,
					height: frame.height,
					data: frame.data,
					frameIndex
				};

				const startServerTime = performance.now();
				queue.enqueue({ frame, totalSegmentationTime, startServerTime, frameIndex });
				socket.emit('frame', request);

				frameIndex++;

				if (!videoHasEnded) {
					media.el.requestVideoFrameCallback(saveFrame);
				}
			}

			let addCubeInterval = null;

			const receiveFrame = (message) => {
				const item = queue.dequeue();

				if(!item) {
					console.log("fila vazia")
					return;
				}

        		const {data, totalSlamTime, queueTime } = message;
				const { frame, totalSegmentationTime, startServerTime, frameIndex } = item;
				const frameIndex2 = message.frameIndex;

				// console.log('frameIndex - ' + frameIndex);
				// console.log('frameIndex2 - ' + frameIndex2);

				// console.log(queue.size());
				// console.log( frameIndex === frameIndex2);
				console.log(totalSlamTime);
				
				const endServerTime = performance.now();
				const totalServerTime = endServerTime - startServerTime;
				const totalNetworkTime = totalServerTime - queueTime;

				let pose = null;
				let planePose = null;
				let dots = [];

				if (data) {
					if (data.pose) {
						pose = new Float32Array(data.pose)
					}

					if (data.planePose) {
						planePose = new Float32Array(data.planePose)
					}

					if (data.dots) {
						dots = data.dots
					}
				}

				const startRenderTime = performance.now();

				ctx.clearRect(0, 0, media.width, media.height);
				ctx.putImageData(frame, 0, 0);

				if (pose) {
					camRenderer.updateCameraPose(pose);

					if (addCube && planePose) {
						camRenderer.createObjectWithPose(planePose);
						addCube = false;
					}
				}

				for (const dot of dots) {
					ctx.fillStyle = 'white';
					ctx.fillRect(dot.x, dot.y, 2, 2);
				}

				const endRenderTime = performance.now();

				const totalRenderTime = endRenderTime - startRenderTime;

				const totalTime = totalSegmentationTime + totalNetworkTime + totalRenderTime + totalSlamTime;

				statistics.push([
					totalTime,
					totalSlamTime,
					totalNetworkTime,
					totalRenderTime,
					totalSegmentationTime
				]);

				if(queue.isEmpty() && videoHasEnded){
					ctx.clearRect(0, 0, media.width, media.height);
					addCubeInterval && clearInterval(addCubeInterval);
					getCSV(statistics, "offloading"); // Uncomment to save statistics in CSV file 
					window.dispatchEvent(eventEnd);
				}
			}
			
			if (socket) {
				media.el.play();
				media.el.loop = false;
				
				addCubeInterval = setInterval(() => {
					addCube = true;
				}, 200);
				
				media.el.onended = () => videoHasEnded = true;
				window.dispatchEvent(eventStart);
				media.el.requestVideoFrameCallback(saveFrame);
				socket.on('responseFrame', (message) => receiveFrame(message));
			}
		}

		window.addEventListener('load', main);
	</script>
</body>

</html>
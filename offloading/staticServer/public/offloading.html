<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"
		name="viewport" />
	<meta content="IE=edge" http-equiv="X-UA-Compatible" />
	<title>AlvaAR Video</title>
	<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		*:focus {
			outline: none !important
		}

		html,
		body {
			font-family: 'Helvetica', sans-serif;
			width: 100vw;
			height: 100vh;
			font-size: 12px;
			font-weight: 300;
			background: #fff;
		}

		#container {
			padding-bottom: 50px;
			text-align: center;
			display: none;
			position: relative;
			user-select: none;
		}

		#container::after {
			content: "Click on video to add 3d objects";
			text-align: center;
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
		}

		#container>div {
			display: inline-flex;
			vertical-align: top;
			margin: 100px 15px 0 15px;
			padding: 0;
			position: relative;
			user-select: none;
			outline: 1px solid #d20000;
		}

		#container>div>canvas {
			position: absolute;
			left: 0;
			top: 0;
			user-select: none;
		}

		#container>div>canvas:first-child {
			display: inline-block;
			position: relative;
		}

		.tracking #container>div {
			outline: 1px solid #bebebe;
		}

		@media only screen and (max-device-width: 800px) {
			body {
				background: #000;
			}

			#container {
				padding-bottom: 0;
				text-align: center;
				background: #000;
			}

			#container::after {
				display: none;
				content: '';
			}

			#container>div {
				margin: 0;
				padding: 0;
				box-shadow: none;
			}

			#renderer-map {
				display: none !important;
			}
		}
	</style>
</head>

<body>
	<div id="container">
		<div id="renderer-cam">
			<canvas id="renderer-video"></canvas>
		</div>
		<div id="renderer-map"></div>
	</div>
	<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"
		integrity="sha384-Gr6Lu2Ajx28mzwyVR8CFkULdCU7kMlZ9UthllibdOSo6qAiN+yXNHqtgdTvFXMT4"
		crossorigin="anonymous"></script>
	<script type="module">
		import { ARSimpleView, ARSimpleMap } from "/scripts/view.js";
		import { Video, onFrame, getCSV } from "/scripts/utils.js";

		function imageDataToBlob(imageData) {
			const tmpCanvas = document.createElement('canvas');
			const ctx = tmpCanvas.getContext('2d');
			tmpCanvas.width = imageData.width;
			tmpCanvas.height = imageData.height;
			ctx.putImageData(imageData, 0, 0);

			return new Promise(resolve => tmpCanvas.toBlob(resolve));
		}

		async function blobToImageData(blob, width, height) {
			const canvas = createCanvas(width, height)

			const url = URL.createObjectURL(blob);         // create an Object URL
			const img = new Image();                       // create a temp. image object
			let context = null;

			return new Promise(resolve => {
				img.onload = () => { // handle async image loading
					URL.revokeObjectURL(img.src); // free memory held by Object URL
					context = canvas.getContext("2d")
					context.drawImage(img, 0, 0); // draw image onto canvas (lazy method™)
					const imageData = context.getImageData(0, 0, width, height);
					resolve(imageData);
				};

				img.src = url;
			})
		}

		function imageDataToDataUrl(imageData) {
			const tmpCanvas = document.createElement('canvas');
			const ctx = tmpCanvas.getContext('2d');
			tmpCanvas.width = imageData.width;
			tmpCanvas.height = imageData.height;
			ctx.putImageData(imageData, 0, 0);

			const img = new Image();
			img.src = tmpCanvas.toDataURL();
			return img;
		}

		async function dataUrlToImageData(dataUrl, width, height) {
			if (dataUrl === undefined || dataUrl === null) {
				return;
			}

			const canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			const context = canvas.getContext('2d');
			const image = new Image();

			return new Promise(resolve => {
				image.onload = () => {
					context.drawImage(image, 0, 0, width, height);
					const imageData = context.getImageData(0, 0, width, height);
					resolve(imageData);
				}

				image.src = dataUrl;
			})
		}

		function roughSizeOfObject(object) {
			const objectList = [];
			const stack = [object];
			let bytes = 0;

			while (stack.length) {
				const value = stack.pop();

				switch (typeof value) {
					case 'boolean':
						bytes += 4;
						break;
					case 'string':
						bytes += value.length * 2;
						break;
					case 'number':
						bytes += 8;
						break;
					case 'object':
						if (!objectList.includes(value)) {
							objectList.push(value);
							for (const prop in value) {
								if (value.hasOwnProperty(prop)) {
									stack.push(value[prop]);
								}
							}
						}
						break;
				}
			}

			return bytes;
		}

		function dataUrlSize(dataUrl) {
			const base64str = dataUrl.src.substr(22);
			const decoded = atob(base64str);
			return decoded.length;
		}

		// const senderUrl = "192.168.10.2:3000";
		const senderUrl = "localhost:3000";
		// const receiverUrl = "192.168.10.2:3001";
		const receiverUrl = "localhost:3001";

		const eventStart = new Event("start");
		const eventEnd = new Event("end");

		const initializeServer = async (senderUrl, receiverUrl, width, height) => {
			const socketSender = io(senderUrl, { reconnection: false });

			await new Promise(resolve => {
				socketSender.io.on("error", (error) => {
					error = new Error("Could not connect to " + senderUrl);
					window.alert("Não foi possível conectar ao servidor");
					console.error(error);
				});
				resolve();
			});

			const socketReceiver = await new Promise((resolve) => socketSender.on('connect', () => {
				socketSender.emit('initialize alva', { width, height }, () => {
					const socketReceiver = io(receiverUrl, { reconnection: false });
					socketReceiver.on('connect', () => resolve(socketReceiver));
				});
			}));

			return [socketSender, socketReceiver];
		}

		async function main() {
			const media = await Video.Initialize('/videos/wasm.mp4');

			const socketPromise = initializeServer(senderUrl, receiverUrl, media.width, media.height);

			let statistics =
				[
					[
						'slamTime',
						'networkTime',
						'renderTime',
						'segmentationTime',
						'totalClientServerTime',
						'totalServerClientTime',
						'screenTime',
						'compressionTime',
						'decompressionTime',
					]
				];

			const $cam = document.getElementById('renderer-cam');
			const $map = document.getElementById('renderer-map');
			const ctx = document.getElementById('renderer-video').getContext('2d');

			ctx.canvas.width = media.width;
			ctx.canvas.height = media.height;

			const mapRenderer = new ARSimpleMap($map, media.width, media.height);
			const camRenderer = new ARSimpleView($cam, media.width, media.height, mapRenderer);
			$cam.parentElement.style.display = 'block';

			let videoHasEnded = false;
			let addCube = false;

			let totalFrames = 0;

			const [socketSender, socketReceiver] = await socketPromise;

			let frameIndex = 0;
			let fpsTimer = 0;

			const saveFrame = async () => {
				if (frameIndex === 0) {
					fpsTimer = performance.now();
				}

				const startSegmentationTime = performance.now();
				const frame = media.getImageData();

				const endSegmentationTime = performance.now();

				const totalSegmentationTime = endSegmentationTime - startSegmentationTime;

				const startCompressionTime = performance.now();
				// const dataUrl = imageDataToDataUrl(frame);
				const blob = await imageDataToBlob(frame);
				const compressionTime = performance.now() - startCompressionTime;

				const startServerTime = performance.now();

				const request = {
					// dataUrl: dataUrl.src,
					blob,
					frameIndex,
					startClientServerTime: Date.now(),
					totalSegmentationTime,
					compressionTime,
					startServerTime
				};

				socketSender.emit('frame', request);

				frameIndex++;

				if (!videoHasEnded) {
					media.el.requestVideoFrameCallback(saveFrame);
				}
			}

			let addCubeInterval = null;
			let startScreenTime = performance.now();

			const receiveFrame = async (message) => {

				message.totalServerClientTime = Date.now() - message.startServerClientTime;
				delete message.startServerClientTime;

				const {
					// dataUrl,
					blob,
					totalSegmentationTime,
					startServerTime,
					frameIndex,
					slamData,
					totalSlamTime,
					totalServerClientTime,
					totalClientServerTime,
					compressionTime,
					decompressionTime
				} = message;

				const endServerTime = performance.now();
				const totalServerTime = endServerTime - startServerTime;
				const totalNetworkTime = totalServerClientTime + totalClientServerTime;

				let pose = null;
				let planePose = null;
				let dots = [];

				if (slamData) {
					if (slamData.pose) {
						pose = new Float32Array(slamData.pose)
					}

					if (slamData.planePose) {
						planePose = new Float32Array(slamData.planePose)
					}

					if (slamData.dots) {
						dots = slamData.dots
					}
				}


				// const frameImageData = await dataUrlToImageData(dataUrl, media.width, media.height);
				console.log(blob)
				const frameImageData = await blobToImageData(blob, media.width, media.height);
				console.log(frameImageData)

				const startRenderTime = performance.now();

				const screenTime = performance.now() - startScreenTime;
				ctx.clearRect(0, 0, media.width, media.height);
				ctx.putImageData(frameImageData, 0, 0);
				startScreenTime = performance.now();

				if (pose) {
					camRenderer.updateCameraPose(pose);

					if (addCube && planePose) {
						camRenderer.createObjectWithPose(planePose);
						addCube = false;
					}
				}

				for (const dot of dots) {
					ctx.fillStyle = 'white';
					ctx.fillRect(dot.x, dot.y, 2, 2);
				}

				const endRenderTime = performance.now();

				const totalRenderTime = endRenderTime - startRenderTime;

				statistics.push([
					totalSlamTime,
					totalNetworkTime,
					totalRenderTime,
					totalSegmentationTime,
					totalClientServerTime,
					totalServerClientTime,
					screenTime,
					compressionTime,
					decompressionTime,
				]);

				//console.log(message.frameIndex);

				if (message.frameIndex === totalFrames - 1 && videoHasEnded) {
					const time = (performance.now() - fpsTimer) / 1000;
					const fps = (statistics.length - 1) / time;
					statistics[0].push('fps');
					statistics[1].push(fps);
					ctx.clearRect(0, 0, media.width, media.height);
					addCubeInterval && clearInterval(addCubeInterval);
					getCSV(statistics, "offloading"); // Uncomment to save statistics in CSV file 
					window.dispatchEvent(eventEnd);
				}
			}

			if (socketReceiver && socketSender) {
				media.el.play();
				media.el.loop = false;

				addCubeInterval = setInterval(() => {
					addCube = true;
				}, 200);

				media.el.onended = () => {
					totalFrames = frameIndex;
					console.log("Ultimo frame: " + totalFrames)
					videoHasEnded = true;
				};
				window.dispatchEvent(eventStart);
				media.el.requestVideoFrameCallback(saveFrame);
				socketReceiver.on('responseFrame', (message) => receiveFrame(message));
			}
		}

		window.addEventListener('load', main);
	</script>
</body>

</html>
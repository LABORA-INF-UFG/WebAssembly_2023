<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"
		name="viewport" />
	<meta content="IE=edge" http-equiv="X-UA-Compatible" />
	<title>AlvaAR Video</title>
	<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		*:focus {
			outline: none !important
		}

		html,
		body {
			font-family: 'Helvetica', sans-serif;
			width: 100vw;
			height: 100vh;
			font-size: 12px;
			font-weight: 300;
			background: #fff;
		}

		#container {
			padding-bottom: 50px;
			text-align: center;
			display: none;
			position: relative;
			user-select: none;
		}

		#container::after {
			content: "Click on video to add 3d objects";
			text-align: center;
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
		}

		#container>div {
			display: inline-flex;
			vertical-align: top;
			margin: 100px 15px 0 15px;
			padding: 0;
			position: relative;
			user-select: none;
			outline: 1px solid #d20000;
		}

		#container>div>canvas {
			position: absolute;
			left: 0;
			top: 0;
			user-select: none;
		}

		#container>div>canvas:first-child {
			display: inline-block;
			position: relative;
		}

		.tracking #container>div {
			outline: 1px solid #bebebe;
		}

		@media only screen and (max-device-width: 800px) {
			body {
				background: #000;
			}

			#container {
				padding-bottom: 0;
				text-align: center;
				background: #000;
			}

			#container::after {
				display: none;
				content: '';
			}

			#container>div {
				margin: 0;
				padding: 0;
				box-shadow: none;
			}

			#renderer-map {
				display: none !important;
			}
		}
	</style>
</head>

<body>
	<div id="container">
		<div id="renderer-cam">
			<canvas id="renderer-video"></canvas>
		</div>
		<div id="renderer-map"></div>
	</div>
	<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"
		integrity="sha384-Gr6Lu2Ajx28mzwyVR8CFkULdCU7kMlZ9UthllibdOSo6qAiN+yXNHqtgdTvFXMT4" crossorigin="anonymous">
		</script>
	<script
		onload="wasm_bindgen(`https://cdn.jsdelivr.net/npm/wasm-flate@1.0.2-browser/wasm_flate_bg.wasm`)"
		src="https://cdn.jsdelivr.net/npm/wasm-flate@1.0.2-browser/wasm_flate.min.js">
	</script>
	</script>
	<script type="module">
		import { ARSimpleView, ARSimpleMap } from "/scripts/view.js";
		import { Video, onFrame, getCSV, roughSizeOfObject } from "/scripts/utils.js";

		// const senderUrl = "192.168.10.2:3000";
		const senderUrl= "localhost:3000";
		// const receiverUrl = "192.168.10.2:3001";
		const receiverUrl =  "localhost:3001";

		const eventStart = new Event("start");
		const eventEnd = new Event("end");

		const initializeServer = async (senderUrl, receiverUrl, width, height) => {
			const socketSender = io(senderUrl, { reconnection: false });

			await new Promise(resolve => {
				socketSender.io.on("error", (error) => {
					error = new Error("Could not connect to " + senderUrl);
					window.alert("Não foi possível conectar ao servidor");
					console.error(error);
				});
				resolve();
			});

			const socketReceiver = await new Promise((resolve) => socketSender.on('connect', () => {
				socketSender.emit('initialize alva', { width, height }, () => {
					const socketReceiver = io(receiverUrl, { reconnection: false });
					socketReceiver.on('connect', () => resolve(socketReceiver));
				});
			}));

			return [socketSender, socketReceiver];
		}

		async function main() {
			const media = await Video.Initialize('/videos/wasm.mp4');

			const socketPromise = initializeServer(senderUrl, receiverUrl, media.width, media.height);

			let statistics =
				[
					[
						'slamTime',
						'networkTime',
						'renderTime',
						'segmentationTime',
						'totalClientServerTime',
						'totalServerClientTime',
						'screenTime'
					]
				];

			const $cam = document.getElementById('renderer-cam');
			const $map = document.getElementById('renderer-map');
			const ctx = document.getElementById('renderer-video').getContext('2d');

			ctx.canvas.width = media.width;
			ctx.canvas.height = media.height;

			const mapRenderer = new ARSimpleMap($map, media.width, media.height);
			const camRenderer = new ARSimpleView($cam, media.width, media.height, mapRenderer);
			$cam.parentElement.style.display = 'block';

			let videoHasEnded = false;
			let addCube = false;

			let totalFrames = 0;

			const [socketSender, socketReceiver] = await socketPromise;

			let frameIndex = 0;
			let fpsTimer = 0;

			const saveFrame = () => {
				if (frameIndex === 0) {
					fpsTimer = performance.now();
				}

				const startSegmentationTime = performance.now();
				const frame = media.getImageData();
				const endSegmentationTime = performance.now();

				const totalSegmentationTime = endSegmentationTime - startSegmentationTime;

				// const a = wasm_bindgen.flate.deflate_encode_raw(u8intArray)
				const start = performance.now();
				const compress = wasm_bindgen.deflate_encode_raw( frame.data );
				const decompress = wasm_bindgen.deflate_decode_raw( compress );
				console.log('time = ' + (performance.now() - start).toString());
				// console.log(roughSizeOfObject(compress));
				// console.log(roughSizeOfObject(decompress));
				// console.log();
				const a = roughSizeOfObject(frame.data)
				const b = roughSizeOfObject(compress)
				console.log('compression = ' + ((a-b)/a*100).toFixed(2) + '%');

				const startServerTime = performance.now();

				const request = {
					width: frame.width,
					height: frame.height,
					data: frame.data,
					frameIndex,
					startClientServerTime: Date.now(),
					totalSegmentationTime,
					startServerTime
				};

				socketSender.emit('frame', request);

				frameIndex++;

				if (!videoHasEnded) {
					media.el.requestVideoFrameCallback(saveFrame);
				}
			}

			let addCubeInterval = null;
			let startScreenTime = performance.now();

			const receiveFrame = (message) => {

				message.totalServerClientTime = Date.now() - message.startServerClientTime;
				delete message.startServerClientTime;

				const {
					frame,
					width,
					height,
					totalSegmentationTime,
					startServerTime,
					frameIndex,
					data,
					totalSlamTime,
					totalServerClientTime,
					totalClientServerTime
				} = message;

				const endServerTime = performance.now();
				const totalServerTime = endServerTime - startServerTime;
				const totalNetworkTime = totalServerClientTime + totalClientServerTime;

				let pose = null;
				let planePose = null;
				let dots = [];

				if (data) {
					if (data.pose) {
						pose = new Float32Array(data.pose)
					}

					if (data.planePose) {
						planePose = new Float32Array(data.planePose)
					}

					if (data.dots) {
						dots = data.dots
					}
				}

				const frameImageData = new ImageData(new Uint8ClampedArray(frame), width, height);

				const startRenderTime = performance.now();

				const screenTime = performance.now() - startScreenTime;
				ctx.clearRect(0, 0, media.width, media.height);
				ctx.putImageData(frameImageData, 0, 0);
				startScreenTime = performance.now();

				if (pose) {
					camRenderer.updateCameraPose(pose);

					if (addCube && planePose) {
						camRenderer.createObjectWithPose(planePose);
						addCube = false;
					}
				}

				for (const dot of dots) {
					ctx.fillStyle = 'white';
					ctx.fillRect(dot.x, dot.y, 2, 2);
				}

				const endRenderTime = performance.now();

				const totalRenderTime = endRenderTime - startRenderTime;

				statistics.push([
					totalSlamTime,
					totalNetworkTime,
					totalRenderTime,
					totalSegmentationTime,
					totalClientServerTime,
					totalServerClientTime,
					screenTime
				]);

				if (message.frameIndex === totalFrames - 1 && videoHasEnded) {
					const time = (performance.now() - fpsTimer) / 1000;
					const fps = (statistics.length - 1) / time;
					statistics[0].push('fps');
					statistics[1].push(fps);
					ctx.clearRect(0, 0, media.width, media.height);
					addCubeInterval && clearInterval(addCubeInterval);
					getCSV(statistics, "offloading"); // Uncomment to save statistics in CSV file 
					window.dispatchEvent(eventEnd);
				}
			}

			if (socketReceiver && socketSender) {
				media.el.play();
				media.el.loop = false;

				addCubeInterval = setInterval(() => {
					addCube = true;
				}, 200);

				media.el.onended = () => {
					totalFrames = frameIndex;
					console.log("Ultimo frame: " + totalFrames)
					videoHasEnded = true;
				};
				window.dispatchEvent(eventStart);
				media.el.requestVideoFrameCallback(saveFrame);
				socketReceiver.on('responseFrame', (message) => receiveFrame(message));
			}
		}

		window.addEventListener('load', main);
	</script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"
    name="viewport" />
  <meta content="IE=edge" http-equiv="X-UA-Compatible" />
  <title>AlvaAR Video</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    *:focus {
      outline: none !important
    }

    html,
    body {
      font-family: 'Helvetica', sans-serif;
      width: 100vw;
      height: 100vh;
      font-size: 12px;
      font-weight: 300;
      background: #fff;
    }

    #container {
      padding-bottom: 50px;
      text-align: center;
      display: none;
      position: relative;
      user-select: none;
    }

    #container::after {
      content: "Click on video to add 3d objects";
      text-align: center;
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
    }

    #container>div {
      display: inline-flex;
      vertical-align: top;
      margin: 100px 15px 0 15px;
      padding: 0;
      position: relative;
      user-select: none;
      outline: 1px solid #d20000;
    }

    #container>div>canvas {
      position: absolute;
      left: 0;
      top: 0;
      user-select: none;
    }

    #container>div>canvas:first-child {
      display: inline-block;
      position: relative;
    }

    .tracking #container>div {
      outline: 1px solid #bebebe;
    }

    @media only screen and (max-device-width: 800px) {
      body {
        background: #000;
      }

      #container {
        padding-bottom: 0;
        text-align: center;
        background: #000;
      }

      #container::after {
        display: none;
        content: '';
      }

      #container>div {
        margin: 0;
        padding: 0;
        box-shadow: none;
      }

      #renderer-map {
        display: none !important;
      }
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="renderer-cam">
      <canvas id="renderer-video"></canvas>
    </div>
    <div id="renderer-map"></div>
  </div>
  <!-- TODO: DECIDIR QUAL LINK USAR PARA PEGAR A BIBLIOTECA DO SOCKET.IO -->
  <!-- <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"
    integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+"
    crossorigin="anonymous"></script> -->
  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import { ARSimpleView, ARSimpleMap } from "/scripts/view.js";
    import { Video, onFrame, getCSV, roughSizeOfObject } from "/scripts/utils.js";

    const serverUrl = "localhost:3000";

    const initializeServer = async (serverUrl, width, height) => {
      const socket = io(serverUrl, { reconnection: false });

      await new Promise(resolve => {
        socket.io.on("error", (error) => {
          error = new Error("Could not connect to " + serverUrl);
          window.alert("Não foi possível conectar ao servidor");
          console.error(error);
        });
        resolve();
      });

      await new Promise((resolve) => socket.on('connect', () => {
        socket.emit('initialize alva', { width, height });
        resolve();
      }));

      return socket;
    }

    async function main() {
      const media = await Video.Initialize('/videos/video-short.mp4');

      const socketPromise = initializeServer(serverUrl, media.width, media.height);

      let statistics = [
        ['serverTime', 'slamTime', 'streamingTime', 'renderTime', 'videoTime', 'clientMemoryUsage', 'serverMemoryUsage', 'requestSize', 'responseSize']
      ];

      const $cam = document.getElementById('renderer-cam');
      const $map = document.getElementById('renderer-map');
      const ctx = document.getElementById('renderer-video').getContext('2d');

      ctx.canvas.width = media.width;
      ctx.canvas.height = media.height;

      const mapRenderer = new ARSimpleMap($map, media.width, media.height);
      const camRenderer = new ARSimpleView($cam, media.width, media.height, mapRenderer);
      $cam.parentElement.style.display = 'block';

      let videoHasEnded = false;
      let addCube = false;

      const socket = await socketPromise;

      const processFrame = async (now, frameMetadata) => {
        const startVideoTime = performance.now();
        const frame = media.getImageData();
        const endVideoTime = performance.now();

        const totalVideoTime = endVideoTime - startVideoTime;

        const startServerTime = performance.now();

        let requestSize = 0;
        let responseSize = 0;

        const [data, totalSlamTime, serverMemoryUsage] = await new Promise(resolve => {
          const request = {
            width: frame.width,
            height: frame.height,
            data: frame.data
          };

          requestSize = roughSizeOfObject(request);

          socket.emit(
            'frame',
            request,
            (response) => {
              responseSize = roughSizeOfObject(response);
              resolve(response);
            }
          );
        });

        let pose = null;
        let planePose = null;
        let dots = [];

        if (data) {
          if (data.pose) {
            pose = new Float32Array(data.pose)
          }

          if (data.planePose) {
            planePose = new Float32Array(data.planePose)
          }

          if (data.dots) {
            dots = data.dots
          }

        }

        const endServerTime = performance.now();

        const totalServerTime = endServerTime - startServerTime;
        const totalStreamingTime = totalServerTime - totalSlamTime;

        const startRenderTime = performance.now();

        ctx.clearRect(0, 0, media.width, media.height);
        ctx.putImageData(frame, 0, 0);

        if (pose) {
          camRenderer.updateCameraPose(pose);

          if (addCube && planePose) {
            camRenderer.createObjectWithPose(planePose);
            addCube = false;
          }

        }

        for (const dot of dots) {
          ctx.fillStyle = 'white';
          ctx.fillRect(dot.x, dot.y, 2, 2);
        }

        const endRenderTime = performance.now();

        const totalRenderTime = endRenderTime - startRenderTime;

        const clientMemoryUsage = performance.memory.usedJSHeapSize;

        statistics.push([
          totalServerTime,
          totalSlamTime,
          totalStreamingTime,
          totalRenderTime,
          totalVideoTime,
          clientMemoryUsage,
          serverMemoryUsage,
          requestSize,
          responseSize
        ]);

        if (!videoHasEnded) {
          media.el.requestVideoFrameCallback(processFrame);
        }

        // return !videoHasEnded
      }

      if (socket) {
        media.el.play();
        media.el.loop = false;

        const addCubeInterval = setInterval(() => {
          addCube = true;
        }, 2000);

        const endVideo = async () => {
          videoHasEnded = true;
          ctx.clearRect(0, 0, media.width, media.height);
          clearInterval(addCubeInterval);
          // getCSV(statistics, "offloading"); // Uncomment to save statistics in CSV file 
        }

        media.el.onended = endVideo;

        media.el.requestVideoFrameCallback(processFrame);
        // onFrame(processFrame, 30);
      }

    }


    window.addEventListener('load', main);
  </script>
</body>

</html>